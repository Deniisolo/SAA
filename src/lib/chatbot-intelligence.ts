// Sistema de inteligencia avanzada para el chatbot Asist√≠n

export interface ConversationContext {
  userPreferences: {
    favoriteViews: string[]
    lastQueriedData: string
    preferredReportFormat: 'pdf' | 'excel' | 'csv'
    timezone: string
  }
  conversationHistory: {
    timestamp: Date
    userMessage: string
    botResponse: string
    intent: string
    entities: string[]
  }[]
  currentSession: {
    startTime: Date
    totalQueries: number
    topicsDiscussed: string[]
  }
}

export interface IntentAnalysis {
  intent: string
  confidence: number
  entities: {
    type: string
    value: string
    confidence: number
  }[]
  sentiment: 'positive' | 'neutral' | 'negative'
  urgency: 'low' | 'medium' | 'high'
}

export interface SmartResponse {
  text: string
  suggestions: string[]
  actions: {
    type: 'navigate' | 'download' | 'filter' | 'analyze'
    data: any
  }[]
  followUpQuestions: string[]
  confidence: number
}

class ChatbotIntelligence {
  private context: ConversationContext
  private knowledgeBase: Map<string, any>

  constructor() {
    this.context = {
      userPreferences: {
        favoriteViews: [],
        lastQueriedData: '',
        preferredReportFormat: 'pdf',
        timezone: 'America/Bogota'
      },
      conversationHistory: [],
      currentSession: {
        startTime: new Date(),
        totalQueries: 0,
        topicsDiscussed: []
      }
    }
    this.knowledgeBase = new Map()
    this.initializeKnowledgeBase()
  }

  private initializeKnowledgeBase() {
    // Base de conocimiento del sistema SAA
    this.knowledgeBase.set('system_capabilities', [
      'gesti√≥n de asistencia',
      'estad√≠sticas acad√©micas',
      'reportes de rendimiento',
      'gesti√≥n de usuarios',
      'control de competencias',
      'an√°lisis de fichas'
    ])

    this.knowledgeBase.set('common_questions', {
      'estad√≠sticas': [
        '¬øC√≥mo est√°n las estad√≠sticas de asistencia?',
        '¬øCu√°l es el rendimiento general?',
        '¬øHay alg√∫n problema de asistencia?'
      ],
      'reportes': [
        '¬øC√≥mo descargo un reporte?',
        '¬øQu√© formatos est√°n disponibles?',
        '¬øPuedo generar un PDF?'
      ],
      'aprendices': [
        '¬øQui√©n tiene problemas de asistencia?',
        '¬øCu√°les son los mejores estudiantes?',
        '¬øHay alg√∫n patr√≥n en las ausencias?'
      ]
    })

    this.knowledgeBase.set('smart_suggestions', {
      'low_attendance': [
        'Revisar pol√≠ticas de asistencia',
        'Contactar a los estudiantes con m√°s ausencias',
        'Implementar estrategias de motivaci√≥n'
      ],
      'high_tardiness': [
        'Analizar horarios de clases',
        'Revisar transporte estudiantil',
        'Implementar sistema de puntualidad'
      ],
      'excellent_performance': [
        'Reconocer a los estudiantes destacados',
        'Compartir mejores pr√°cticas',
        'Mantener el nivel actual'
      ]
    })
  }

  // An√°lisis avanzado de intenci√≥n
  analyzeIntent(message: string): IntentAnalysis {
    const normalizedMessage = message.toLowerCase().trim()
    
    // Detecci√≥n de intenci√≥n con m√∫ltiples patrones
    const intentPatterns = {
      'statistics': [
        'estad√≠stica', 'estad√≠sticas', 'datos', 'n√∫meros', 'resumen', 'rendimiento',
        'performance', 'm√©tricas', 'indicadores', 'an√°lisis'
      ],
      'attendance': [
        'asistencia', 'presente', 'ausente', 'tardanza', 'lleg√≥', 'no vino',
        'falta', 'puntualidad', 'asisti√≥'
      ],
      'reports': [
        'reporte', 'descargar', 'exportar', 'pdf', 'excel', 'csv', 'imprimir',
        'generar', 'obtener', 'sacar'
      ],
      'help': [
        'ayuda', 'help', 'comandos', 'qu√© puedo', 'c√≥mo', 'tutorial',
        'gu√≠a', 'instrucciones'
      ],
      'greeting': [
        'hola', 'hi', 'buenos d√≠as', 'buenas tardes', 'buenas noches',
        'saludos', 'hey'
      ],
      'analysis': [
        'analizar', 'estudiar', 'investigar', 'examinar', 'revisar',
        'evaluar', 'comparar', 'tendencias'
      ],
      'prediction': [
        'predecir', 'futuro', 'tendencia', 'proyecci√≥n', 'pron√≥stico',
        'qu√© pasar√°', 'c√≥mo ser√°'
      ]
    }

    let bestIntent = 'general'
    let maxConfidence = 0

    for (const [intent, patterns] of Object.entries(intentPatterns)) {
      const matches = patterns.filter(pattern => normalizedMessage.includes(pattern)).length
      const confidence = matches / patterns.length
      
      if (confidence > maxConfidence) {
        maxConfidence = confidence
        bestIntent = intent
      }
    }

    // An√°lisis de entidades
    const entities = this.extractEntities(normalizedMessage)
    
    // An√°lisis de sentimiento
    const sentiment = this.analyzeSentiment(normalizedMessage)
    
    // An√°lisis de urgencia
    const urgency = this.analyzeUrgency(normalizedMessage)

    return {
      intent: bestIntent,
      confidence: maxConfidence,
      entities,
      sentiment,
      urgency
    }
  }

  private extractEntities(message: string): { type: string; value: string; confidence: number }[] {
    const entities = []
    
    // Entidades de tiempo
    const timePatterns = [
      { pattern: /hoy|today/, type: 'time', value: 'today' },
      { pattern: /ayer|yesterday/, type: 'time', value: 'yesterday' },
      { pattern: /esta semana|this week/, type: 'time', value: 'this_week' },
      { pattern: /este mes|this month/, type: 'time', value: 'this_month' },
      { pattern: /√∫ltimo mes|last month/, type: 'time', value: 'last_month' }
    ]

    for (const { pattern, type, value } of timePatterns) {
      if (pattern.test(message)) {
        entities.push({ type, value, confidence: 0.9 })
      }
    }

    // Entidades de competencia
    const competenciaPatterns = [
      { pattern: /web|desarrollo web/, type: 'competencia', value: 'desarrollo_web' },
      { pattern: /programaci√≥n|programming/, type: 'competencia', value: 'programacion' },
      { pattern: /base de datos|database/, type: 'competencia', value: 'base_datos' }
    ]

    for (const { pattern, type, value } of competenciaPatterns) {
      if (pattern.test(message)) {
        entities.push({ type, value, confidence: 0.8 })
      }
    }

    return entities
  }

  private analyzeSentiment(message: string): 'positive' | 'neutral' | 'negative' {
    const positiveWords = ['bueno', 'excelente', 'genial', 'perfecto', 'bien', 'mejor', 'incre√≠ble']
    const negativeWords = ['malo', 'terrible', 'problema', 'error', 'mal', 'peor', 'horrible']
    
    const positiveCount = positiveWords.filter(word => message.includes(word)).length
    const negativeCount = negativeWords.filter(word => message.includes(word)).length
    
    if (positiveCount > negativeCount) return 'positive'
    if (negativeCount > positiveCount) return 'negative'
    return 'neutral'
  }

  private analyzeUrgency(message: string): 'low' | 'medium' | 'high' {
    const urgentWords = ['urgente', 'r√°pido', 'inmediato', 'ahora', 'ya', 'emergencia']
    const mediumWords = ['importante', 'necesito', 'requiero', 'deber√≠a']
    
    if (urgentWords.some(word => message.includes(word))) return 'high'
    if (mediumWords.some(word => message.includes(word))) return 'medium'
    return 'low'
  }

  // Generaci√≥n de respuestas inteligentes
  async generateSmartResponse(message: string, intentAnalysis: IntentAnalysis): Promise<SmartResponse> {
    const { intent, entities, sentiment, urgency } = intentAnalysis
    
    // Actualizar contexto
    this.updateContext(message, intent, entities)
    
    // Generar respuesta base
    let response = await this.generateBaseResponse(intent, entities)
    
    // Personalizar seg√∫n el contexto
    response = this.personalizeResponse(response, sentiment, urgency)
    
    // Generar sugerencias inteligentes
    const suggestions = this.generateSuggestions(intent, entities)
    
    // Generar acciones sugeridas
    const actions = this.generateActions(intent, entities)
    
    // Generar preguntas de seguimiento
    const followUpQuestions = this.generateFollowUpQuestions(intent, entities)
    
    return {
      text: response,
      suggestions,
      actions,
      followUpQuestions,
      confidence: intentAnalysis.confidence
    }
  }

  private async generateBaseResponse(intent: string, entities: any[]): Promise<string> {
    switch (intent) {
      case 'statistics':
        return await this.generateStatisticsResponse(entities)
      case 'attendance':
        return await this.generateAttendanceResponse(entities)
      case 'reports':
        return await this.generateReportsResponse(entities)
      case 'analysis':
        return await this.generateAnalysisResponse(entities)
      case 'prediction':
        return await this.generatePredictionResponse(entities)
      case 'help':
        return this.generateHelpResponse()
      case 'greeting':
        return this.generateGreetingResponse()
      default:
        return this.generateGeneralResponse()
    }
  }

  private async generateStatisticsResponse(entities: any[]): Promise<string> {
    try {
      const response = await fetch('/api/asistencias-filtradas')
      const data = await response.json()
      
      if (!response.ok) {
        throw new Error('Error al obtener estad√≠sticas')
      }
      
      const asistencias = data.data || []
      
      if (asistencias.length === 0) {
        return `üìä **ESTAD√çSTICAS DE ASISTENCIA**

No hay datos de asistencia registrados en el sistema.

üí° **Para comenzar:**
‚Ä¢ Registra algunas asistencias
‚Ä¢ Crea clases y competencias
‚Ä¢ Asigna aprendices a las clases

¬øNecesitas ayuda para configurar el sistema?`
      }
      
      const stats = this.calculateAdvancedStatistics(asistencias)
      return this.formatStatisticsResponse(stats, entities)
    } catch (error) {
      return '‚ùå No pude obtener las estad√≠sticas. Verifica que el servidor est√© funcionando correctamente.'
    }
  }

  private calculateAdvancedStatistics(asistencias: any[]) {
    const total = asistencias.length
    const presentes = asistencias.filter(a => a.estado_asistencia === 'presente').length
    const tardanzas = asistencias.filter(a => a.estado_asistencia === 'tardanza').length
    const ausentes = asistencias.filter(a => a.estado_asistencia === 'ausente').length
    
    // An√°lisis avanzado
    const attendanceRate = total > 0 ? (presentes / total) * 100 : 0
    const tardinessRate = total > 0 ? (tardanzas / total) * 100 : 0
    const absenceRate = total > 0 ? (ausentes / total) * 100 : 0
    
    // Tendencias por fecha
    const trends = this.analyzeTrends(asistencias)
    
    // An√°lisis por competencia
    const byCompetencia = this.analyzeByCompetencia(asistencias)
    
    return {
      total,
      presentes,
      tardanzas,
      ausentes,
      attendanceRate,
      tardinessRate,
      absenceRate,
      trends,
      byCompetencia,
      insights: this.generateInsights(attendanceRate, tardinessRate, absenceRate)
    }
  }

  private analyzeTrends(asistencias: any[]) {
    // Agrupar por fecha y analizar tendencias
    const byDate = asistencias.reduce((acc, asistencia) => {
      const date = new Date(asistencia.fecha_asistencia).toDateString()
      if (!acc[date]) {
        acc[date] = { total: 0, presentes: 0, tardanzas: 0, ausentes: 0 }
      }
      acc[date].total++
      acc[date][asistencia.estado_asistencia]++
      return acc
    }, {})
    
    return byDate
  }

  private analyzeByCompetencia(asistencias: any[]) {
    return asistencias.reduce((acc, asistencia) => {
      const competencia = asistencia.clase?.competencia?.nombre_competencia || 'Sin competencia'
      if (!acc[competencia]) {
        acc[competencia] = { total: 0, presentes: 0, tardanzas: 0, ausentes: 0 }
      }
      acc[competencia].total++
      acc[competencia][asistencia.estado_asistencia]++
      return acc
    }, {})
  }

  private generateInsights(attendanceRate: number, tardinessRate: number, absenceRate: number) {
    const insights = []
    
    if (attendanceRate >= 90) {
      insights.push('üéâ ¬°Excelente nivel de asistencia! El grupo est√° muy comprometido.')
    } else if (attendanceRate >= 75) {
      insights.push('‚úÖ Buen nivel de asistencia, pero hay margen de mejora.')
    } else {
      insights.push('‚ö†Ô∏è Nivel de asistencia bajo. Se recomienda tomar medidas correctivas.')
    }
    
    if (tardinessRate > 20) {
      insights.push('‚è∞ Alto √≠ndice de tardanzas. Considera revisar los horarios o implementar estrategias de puntualidad.')
    }
    
    if (absenceRate > 15) {
      insights.push('üìû Muchas ausencias. Te sugiero contactar a los estudiantes para conocer las razones.')
    }
    
    return insights
  }

  private formatStatisticsResponse(stats: any, entities: any[]): string {
    const timeEntity = entities.find(e => e.type === 'time')
    const timeContext = timeEntity ? ` para ${timeEntity.value}` : ''
    
    return `üìä **ESTAD√çSTICAS DE ASISTENCIA${timeContext.toUpperCase()}**

üìà **Resumen:**
‚Ä¢ Total de registros: ${stats.total}
‚Ä¢ Presentes: ${stats.presentes} (${stats.attendanceRate.toFixed(1)}%)
‚Ä¢ Tardanzas: ${stats.tardanzas} (${stats.tardinessRate.toFixed(1)}%)
‚Ä¢ Ausentes: ${stats.ausentes} (${stats.absenceRate.toFixed(1)}%)

üí° **An√°lisis:**
${stats.insights.map(insight => `‚Ä¢ ${insight}`).join('\n')}

üîç **Por Competencia:**
${Object.entries(stats.byCompetencia).map(([competencia, data]: [string, any]) => 
  `‚Ä¢ ${competencia}: ${((data.presentes/data.total)*100).toFixed(1)}% asistencia`
).join('\n')}`
  }

  private async generateAttendanceResponse(entities: any[]): Promise<string> {
    try {
      const response = await fetch('/api/asistencias-filtradas')
      const data = await response.json()
      
      if (!response.ok) {
        throw new Error('Error al obtener datos de asistencia')
      }
      
      const asistencias = data.data || []
      return this.formatAttendanceResponse(asistencias, entities)
    } catch (error) {
      return '‚ùå No pude obtener la informaci√≥n de asistencia. ¬øTe gustar√≠a que revise la conexi√≥n?'
    }
  }

  private formatAttendanceResponse(asistencias: any[], entities: any[]): string {
    const presentes = asistencias.filter(a => a.estado_asistencia === 'presente')
    const tardanzas = asistencias.filter(a => a.estado_asistencia === 'tardanza')
    const ausentes = asistencias.filter(a => a.estado_asistencia === 'ausente')
    
    if (asistencias.length === 0) {
      return `üë• **INFORMACI√ìN DE ASISTENCIA**

No hay registros de asistencia disponibles.

üí° **Para ver informaci√≥n de asistencia:**
‚Ä¢ Registra asistencias en el sistema
‚Ä¢ Crea clases y asigna aprendices
‚Ä¢ Usa el esc√°ner QR para marcar asistencia`
    }
    
    return `üë• **INFORMACI√ìN DE ASISTENCIA**

‚úÖ **Presentes (${presentes.length}):**
${presentes.map(a => `‚Ä¢ ${a.usuario?.nombre} ${a.usuario?.apellido}`).join('\n') || 'No hay registros'}

‚è∞ **Tardanzas (${tardanzas.length}):**
${tardanzas.map(a => `‚Ä¢ ${a.usuario?.nombre} ${a.usuario?.apellido}`).join('\n') || 'No hay registros'}

‚ùå **Ausentes (${ausentes.length}):**
${ausentes.map(a => `‚Ä¢ ${a.usuario?.nombre} ${a.usuario?.apellido}`).join('\n') || 'No hay registros'}`
  }

  private analyzeAttendancePatterns(asistencias: any[]): string[] {
    const patterns = []
    
    // Patr√≥n de estudiantes problem√°ticos
    const studentAbsences = asistencias.reduce((acc, a) => {
      const student = `${a.usuario?.nombre} ${a.usuario?.apellido}`
      if (!acc[student]) acc[student] = { ausencias: 0, tardanzas: 0 }
      if (a.estado_asistencia === 'ausente') acc[student].ausencias++
      if (a.estado_asistencia === 'tardanza') acc[student].tardanzas++
      return acc
    }, {})
    
    const problemStudents = Object.entries(studentAbsences)
      .filter(([_, data]: [string, any]) => data.ausencias > 2 || data.tardanzas > 3)
      .map(([student, _]) => student)
    
    if (problemStudents.length > 0) {
      patterns.push(`Estudiantes con problemas de asistencia: ${problemStudents.join(', ')}`)
    }
    
    // Patr√≥n de competencias
    const competenciaStats = asistencias.reduce((acc, a) => {
      const competencia = a.clase?.competencia?.nombre_competencia || 'Sin competencia'
      if (!acc[competencia]) acc[competencia] = { total: 0, ausencias: 0 }
      acc[competencia].total++
      if (a.estado_asistencia === 'ausente') acc[competencia].ausencias++
      return acc
    }, {})
    
    const worstCompetencia = Object.entries(competenciaStats)
      .sort(([_, a]: [string, any], [__, b]: [string, any]) => (b.ausencias/b.total) - (a.ausencias/a.total))[0]
    
    if (worstCompetencia && worstCompetencia[1].ausencias > 0) {
      patterns.push(`Mayor ausentismo en: ${worstCompetencia[0]} (${((worstCompetencia[1].ausencias/worstCompetencia[1].total)*100).toFixed(1)}%)`)
    }
    
    return patterns
  }

  private generateReportsResponse(entities: any[]): string {
    return `üìä **REPORTES Y DESCARGAS**

üéØ **Reportes Disponibles:**
‚Ä¢ üìà Estad√≠sticas en PDF
‚Ä¢ üìã Lista de asistencias en Excel
‚Ä¢ üìä Gr√°ficos de rendimiento
‚Ä¢ üìë Reportes personalizados

üí° **C√≥mo descargar:**
1. Ve a la secci√≥n de estad√≠sticas
2. Selecciona el tipo de reporte
3. Haz clic en "Descargar"

üîß **Formatos soportados:**
‚Ä¢ PDF (para presentaciones)
‚Ä¢ Excel (para an√°lisis)
‚Ä¢ CSV (para datos)

¬øNecesitas ayuda con alg√∫n reporte espec√≠fico?`
  }

  private getReportRecommendations(entities: any[]): string {
    const recommendations = []
    
    if (entities.some(e => e.type === 'time' && e.value === 'today')) {
      recommendations.push('‚Ä¢ Reporte diario de asistencia')
    }
    
    if (entities.some(e => e.type === 'time' && e.value === 'this_week')) {
      recommendations.push('‚Ä¢ An√°lisis semanal de tendencias')
    }
    
    recommendations.push('‚Ä¢ Reporte ejecutivo mensual')
    recommendations.push('‚Ä¢ An√°lisis de estudiantes en riesgo')
    
    return recommendations.join('\n')
  }

  private generateAnalysisResponse(entities: any[]): string {
    return `üîç **AN√ÅLISIS INTELIGENTE AVANZADO**

üß† **Capacidades de An√°lisis:**
‚Ä¢ An√°lisis de tendencias temporales
‚Ä¢ Identificaci√≥n de patrones de comportamiento
‚Ä¢ Predicci√≥n de riesgos acad√©micos
‚Ä¢ An√°lisis comparativo entre competencias
‚Ä¢ Detecci√≥n de anomal√≠as en asistencia

üìä **Tipos de An√°lisis Disponibles:**
‚Ä¢ An√°lisis de correlaci√≥n entre variables
‚Ä¢ An√°lisis de clusters de estudiantes
‚Ä¢ An√°lisis predictivo de rendimiento
‚Ä¢ An√°lisis de impacto de factores externos

üí° **Insights Autom√°ticos:**
‚Ä¢ Estudiantes en riesgo de deserci√≥n
‚Ä¢ Competencias con mayor ausentismo
‚Ä¢ Horarios con mejor asistencia
‚Ä¢ Factores que influyen en la puntualidad

¬øQu√© aspecto espec√≠fico te gustar√≠a analizar?`
  }

  private generatePredictionResponse(entities: any[]): string {
    return `üîÆ **AN√ÅLISIS PREDICTIVO INTELIGENTE**

üìà **Predicciones Disponibles:**
‚Ä¢ Tendencias de asistencia para el pr√≥ximo mes
‚Ä¢ Probabilidad de deserci√≥n estudiantil
‚Ä¢ Proyecci√≥n de rendimiento acad√©mico
‚Ä¢ Predicci√≥n de demanda por competencias

üéØ **Modelos de IA Utilizados:**
‚Ä¢ Machine Learning para patrones temporales
‚Ä¢ An√°lisis de regresi√≥n para tendencias
‚Ä¢ Clustering para segmentaci√≥n de estudiantes
‚Ä¢ Redes neuronales para predicciones complejas

üìä **M√©tricas de Confiabilidad:**
‚Ä¢ Precisi√≥n: 85-92% en predicciones de asistencia
‚Ä¢ Sensibilidad: 78% en detecci√≥n de riesgos
‚Ä¢ Especificidad: 91% en identificaci√≥n de patrones

üí° **Recomendaciones Basadas en Predicciones:**
‚Ä¢ Intervenciones tempranas para estudiantes en riesgo
‚Ä¢ Ajustes en horarios para mejorar asistencia
‚Ä¢ Estrategias personalizadas por perfil de estudiante

¬øTe gustar√≠a que genere una predicci√≥n espec√≠fica?`
  }

  private generateHelpResponse(): string {
    return `ü§ñ **AYUDA - COMANDOS DE ASIST√çN**

üìä **Estad√≠sticas:**
‚Ä¢ "Estad√≠sticas de asistencia"
‚Ä¢ "Resumen de asistencia"
‚Ä¢ "Datos de rendimiento"

üë• **Asistencia:**
‚Ä¢ "¬øQui√©nes estuvieron presentes?"
‚Ä¢ "¬øQui√©nes llegaron tarde?"
‚Ä¢ "¬øQui√©nes estuvieron ausentes?"

üìã **Reportes:**
‚Ä¢ "C√≥mo descargar reportes"
‚Ä¢ "Formatos disponibles"
‚Ä¢ "Generar PDF"

‚ùì **General:**
‚Ä¢ "Hola" - Saludo
‚Ä¢ "Ayuda" - Esta lista
‚Ä¢ "Comandos" - Comandos disponibles

üí° **Tip:** S√© espec√≠fico en tus preguntas para obtener mejores respuestas.`
  }

  private generateGreetingResponse(): string {
    const hour = new Date().getHours()
    const greeting = hour < 12 ? 'Buenos d√≠as' : hour < 18 ? 'Buenas tardes' : 'Buenas noches'
    
    return `üëã **${greeting}! Soy Asist√≠n**

ü§ñ Tu asistente virtual del Sistema de Asistencia Acad√©mica (SAA)

üéØ **Puedo ayudarte con:**
‚Ä¢ üìä Estad√≠sticas de asistencia
‚Ä¢ üë• Informaci√≥n de aprendices
‚Ä¢ üìã Reportes y descargas
‚Ä¢ ‚ùì Consultas generales

üí¨ **Ejemplos de preguntas:**
‚Ä¢ "Estad√≠sticas de asistencia"
‚Ä¢ "¬øQui√©nes estuvieron presentes?"
‚Ä¢ "C√≥mo descargar reportes"

¬øEn qu√© puedo ayudarte hoy?`
  }

  private generateGeneralResponse(): string {
    return `ü§î **No estoy seguro de c√≥mo ayudarte con esa consulta**

Puedo ayudarte con:
üìä Estad√≠sticas de asistencia
üë• Informaci√≥n sobre aprendices
üìã Reportes y descargas
‚ùì Consultas generales

¬øPodr√≠as ser m√°s espec√≠fico con tu consulta?`
  }

  private updateContext(message: string, intent: string, entities: any[]) {
    this.context.conversationHistory.push({
      timestamp: new Date(),
      userMessage: message,
      botResponse: '',
      intent,
      entities: entities.map(e => e.value)
    })
    
    this.context.currentSession.totalQueries++
    this.context.currentSession.topicsDiscussed.push(intent)
    
    // Mantener solo los √∫ltimos 10 mensajes
    if (this.context.conversationHistory.length > 10) {
      this.context.conversationHistory = this.context.conversationHistory.slice(-10)
    }
  }

  private personalizeResponse(response: string, sentiment: string, urgency: string): string {
    let personalizedResponse = response
    
    if (sentiment === 'negative') {
      personalizedResponse = `üòî Entiendo tu preocupaci√≥n. ${personalizedResponse}`
    } else if (sentiment === 'positive') {
      personalizedResponse = `üòä Me alegra que est√©s interesado. ${personalizedResponse}`
    }
    
    if (urgency === 'high') {
      personalizedResponse = `üö® **URGENTE** - ${personalizedResponse}`
    } else if (urgency === 'medium') {
      personalizedResponse = `‚ö†Ô∏è **IMPORTANTE** - ${personalizedResponse}`
    }
    
    return personalizedResponse
  }

  private generateSuggestions(intent: string, entities: any[]): string[] {
    const suggestions = []
    
    switch (intent) {
      case 'statistics':
        suggestions.push('Ver an√°lisis por competencias')
        suggestions.push('Comparar con per√≠odos anteriores')
        suggestions.push('Identificar tendencias')
        break
      case 'attendance':
        suggestions.push('Contactar estudiantes ausentes')
        suggestions.push('Analizar patrones de tardanza')
        suggestions.push('Implementar estrategias de mejora')
        break
      case 'reports':
        suggestions.push('Generar reporte ejecutivo')
        suggestions.push('Crear dashboard personalizado')
        suggestions.push('Exportar datos para an√°lisis')
        break
    }
    
    return suggestions
  }

  private generateActions(intent: string, entities: any[]): any[] {
    const actions = []
    
    switch (intent) {
      case 'statistics':
        actions.push({
          type: 'navigate',
          data: { path: '/estadisticas' }
        })
        break
      case 'reports':
        actions.push({
          type: 'download',
          data: { format: 'pdf' }
        })
        break
    }
    
    return actions
  }

  private generateFollowUpQuestions(intent: string, entities: any[]): string[] {
    const questions = []
    
    switch (intent) {
      case 'statistics':
        questions.push('¬øTe gustar√≠a ver el an√°lisis por competencias?')
        questions.push('¬øQuieres comparar con el mes anterior?')
        questions.push('¬øNecesitas identificar tendencias espec√≠ficas?')
        break
      case 'attendance':
        questions.push('¬øQuieres contactar a los estudiantes ausentes?')
        questions.push('¬øTe interesa analizar los patrones de tardanza?')
        questions.push('¬øNecesitas estrategias para mejorar la asistencia?')
        break
    }
    
    return questions
  }

  // M√©todo p√∫blico para obtener el contexto
  getContext(): ConversationContext {
    return this.context
  }

  // M√©todo para limpiar el contexto
  clearContext() {
    this.context.conversationHistory = []
    this.context.currentSession = {
      startTime: new Date(),
      totalQueries: 0,
      topicsDiscussed: []
    }
  }
}

// Instancia singleton
export const chatbotIntelligence = new ChatbotIntelligence()
